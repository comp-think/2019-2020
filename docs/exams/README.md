# Written examinations (with keys)

In this page it is possible to find the link to the various written examination of the course Computational Thinking and Programming, academic year 2019/2020.

## 14 May 2020 written examination

**Text of the exam:** [PDF](./written-examination-2020-05-14.pdf)

**Solutions:**
* Section 1 (theory):
  1. Cobol, Fortran
     
  2. [Solution](https://comp-think.github.io/exercises/understanding/beginner/exercise-6) available online.
     
  3. [Solution](https://comp-think.github.io/exercises/development/beginner/exercise-12) available online.
  
  4. A Turing machine is composed of an infinite memory tape containing cells. Each cell can contain a symbol (i.e. either 0 or 1, where 0 is the blank symbol, assigned to all the cells in advance) that can be read and written by the head of the machine. The state of the machine at a specific time is recorded. The machine specifies the possible actions to perform in a finite table of instructions. Each instruction in the table says what to do: write a new symbol, move the head either left or right, go to a new state. The machine selects a particular instruction to execute according to the current state and the symbol currently under the head. An initial state and zero or more final states are provided, to define where to start the process, and when to finish it.

* Section 2 (understanding): [Solution](https://comp-think.github.io/exercises/understanding/advanced/exercise-15) available online.

* Section 3 (development): [Solution](https://comp-think.github.io/exercises/development/advanced/exercise-15) available online.

## 30 January 2020 written examination

**Text of the exam:** [PDF](./written-examination-2020-01-30.pdf)

**Solutions:**
* Section 1 (theory):
  1. ENIAC
     
  2. [Solution](https://comp-think.github.io/exercises/understanding/beginner/exercise-5) available online.
     
  3. [Solution](https://comp-think.github.io/exercises/development/beginner/exercise-11) available online.
  
  4. Greedy choice property: at a particular step, we can choose the best candidate for improving the set of candidates bringing to a solution.
  
     Optimal substructure: we must build the optimal solution to a computational problem by considering the optimal solutions to its subproblems.

* Section 2 (understanding): [Solution](https://comp-think.github.io/exercises/understanding/advanced/exercise-14) available online.

* Section 3 (development): [Solution](https://comp-think.github.io/exercises/development/advanced/exercise-14) available online.

