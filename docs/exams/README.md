# Written examinations (with keys)

In this page it is possible to find the link to the various written examination of the course Computational Thinking and Programming, academic year 2019/2020.

## 9 July 2020 written examination

**Text of the exam:** [PDF](./written-examination-2020-07-09.pdf)

**Solutions:**
* Section 1 (theory):
  1. brute-force, greedy
     
  2. The mistakes are:
     * `if item != value_to_search`, that should be `if item == value_to_search`;
     * `return item`, that should be `return value`.
     
  3. [Solution](https://comp-think.github.io/exercises/development/beginner/exercise-14) available online.
  
  4. The ordered structures are lists, queues and stacks. Lists are the most generic ones, and does not force any particular mechanism to add and remove its elements. Instead, a queue adopts a First In First Out (FIFO) strategy to handle its elements, i.e. the first element that is added to the queue is also the first one that will be removed when requested. On the contrary, a stack adopts a Last In First Out (LIFO) strategy to hanlde its elements, i.e. the last element that is added to the stack is also the first one that will be removed when requested.

* Section 2 (understanding): [Solution](https://comp-think.github.io/exercises/understanding/advanced/exercise-17) available online.

* Section 3 (development): [Solution](https://comp-think.github.io/exercises/development/advanced/exercise-17) available online.

## 22 June 2020 written examination

**Text of the exam:** [PDF](./written-examination-2020-06-22.pdf)

**Solutions:**
* Section 1 (theory):
  1. Fortran, Graph
     
  2. [Solution](https://comp-think.github.io/exercises/understanding/beginner/exercise-7) available online.
     
  3. [Solution](https://comp-think.github.io/exercises/development/beginner/exercise-13) available online.
  
  4. Dynamic programming works like the divide and conquer approach. It is an algorithmic technique that splits the original computational problem to solve in two or more smaller problems of the same type. However, differently from divide and conquer, it stores the solutions to these subproblems for reusing them, if they recur. Thus, when a problem recurs, one can look at the previously-computed solution and reuse it directly, usually saving a considerable amount of computation time. 

* Section 2 (understanding): [Solution](https://comp-think.github.io/exercises/understanding/advanced/exercise-16) available online.

* Section 3 (development): [Solution](https://comp-think.github.io/exercises/development/advanced/exercise-16) available online.

## 14 May 2020 written examination

**Text of the exam:** [PDF](./written-examination-2020-05-14.pdf)

**Solutions:**
* Section 1 (theory):
  1. Cobol, Fortran
     
  2. [Solution](https://comp-think.github.io/exercises/understanding/beginner/exercise-6) available online.
     
  3. [Solution](https://comp-think.github.io/exercises/development/beginner/exercise-12) available online.
  
  4. A Turing machine is composed of an infinite memory tape containing cells. Each cell can contain a symbol (i.e. either 0 or 1, where 0 is the blank symbol, assigned to all the cells in advance) that can be read and written by the head of the machine. The state of the machine at a specific time is recorded. The machine specifies the possible actions to perform in a finite table of instructions. Each instruction in the table says what to do: write a new symbol, move the head either left or right, go to a new state. The machine selects a particular instruction to execute according to the current state and the symbol currently under the head. An initial state and zero or more final states are provided, to define where to start the process, and when to finish it.

* Section 2 (understanding): [Solution](https://comp-think.github.io/exercises/understanding/advanced/exercise-15) available online.

* Section 3 (development): [Solution](https://comp-think.github.io/exercises/development/advanced/exercise-15) available online.

## 30 January 2020 written examination

**Text of the exam:** [PDF](./written-examination-2020-01-30.pdf)

**Solutions:**
* Section 1 (theory):
  1. ENIAC
     
  2. [Solution](https://comp-think.github.io/exercises/understanding/beginner/exercise-5) available online.
     
  3. [Solution](https://comp-think.github.io/exercises/development/beginner/exercise-11) available online.
  
  4. Greedy choice property: at a particular step, we can choose the best candidate for improving the set of candidates bringing to a solution.
  
     Optimal substructure: we must build the optimal solution to a computational problem by considering the optimal solutions to its subproblems.

* Section 2 (understanding): [Solution](https://comp-think.github.io/exercises/understanding/advanced/exercise-14) available online.

* Section 3 (development): [Solution](https://comp-think.github.io/exercises/development/advanced/exercise-14) available online.

